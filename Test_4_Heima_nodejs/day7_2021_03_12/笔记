在项目中操作MySQL
    1.步骤
        · 安装操作MySQL数据库的第三方模块(mysql)
        · 通过mysql模块连接到MySQL数据库
        · 通过mysql模块执行SQL语句
    2.安装与配置mysql模块
        i)安装mysql模块
        ii)注册mysql模块
                const mysql = require('mysql')
            //建立与MySQL数据库的连接关系
                const db = mysql.createPool({
                    host:'数据库的ip地址',
                    user:'登录数据库的账号',
                    password:'登录数据库的密码',
                    database:'数据库名'
                })
        iii)测试mysql模块能否正常工作
            通过调用db.query()函数,指定要执行的SQL语句,通过回调函数拿到结果
            //测试
                db.query('select 1',(err,results) => {
                    //mysql模块工作期间报错了
                    if (err) return console.log(err.message)
                    //否则,后台返回SQL语句执行结果
                    console.log(results)
                })
    使用mysql模块操作MySQL数据库
        i)查询数据
            //查询users表中的所有数据
                const sqlStr = 'select * from users'
                db.query(sqlStr,(err,results) => {
                    //查询失败
                    if (err) return console.log(err.message)
                    //否则后台返回结果(如果执行的是select语句,则执行的结果是数组)
                    console.log(results)
                })
        ii)插入数据(这里定义SQL语句时使用便捷方式)
            //需求:向user表中新增数据,其中username为badwoman,password为203954
            //定义要插入的数据
                const user = {username:'badwoman',password:'203954'}
            //定义待执行的SQL语句
                const sqlStr = 'insert into users set ?'
            //执行SQL语句
                db.query(sqlStr,user,(err,results) => {
                    if (err) return console.log(err.message)
                    //这里判断一下作用行数是否为1
                    if (results.affectedRows === 1) return console.log('插入数据成功!')
                }
        iii)更新数据(这里定义SQL语句时使用便捷方式)
            //定义要更新的数据
                const user = {id:6,username:'aaa',password:'000'}
            //定义SQL语句
                const sqlStr = 'update users set ? where id=?'
            //执行SQL语句(这里传参需要以数组形式传入更新数据及更新数据内的id属性)
                db.query(sqlStr,[user,user.id],(err,results) => {
                    if (err) return console.log(err.message)
                    //这里判断作用行数是否为1
                    if (results.affectedRows === 1) return console.log('更新数据成功!')
                })
        iv)删除数据(谨慎)
            在删除数据时,推荐根据id这样的唯一标识来删除对应的数据
            //定义SQL语句
                const sqlStr = 'delete from users where id=?'
            //执行SQL语句
                db.query(sqlStr,(err,results0 => {
                    if (err) return console.log(err.message)
                    //执行delete语句之后,其结果也是一个对象,也会包含作用行数affectedRows属性
                    //判断作用行数是否为1
                    if (results.affectedRows === 1) return console.log('删除数据成功!')
                })
        v)标记删除
            使用DELETE语句,会把真正的数据从表中删除.为了保险起见一般使用标记删除来模拟删除动作
            标记删除就是在表中设置status之类的字段标记当前这条数据是否被删除了.
            //标记删除
            //定义SQL语句
                const sqlStr = 'update users set status=? where id=?'
            //执行SQL语句(这里第二个参数传参一个数组,依次代表定义的SQL语句中的?)
                db.query(sqlStr,[1,1],(err,results) => {
                    if (err) return console.log(err.message)
                //判断作用行数是否为1
                    if (results.affectedRows === 1) return console.log('标记删除成功!')
                }



Web开发模式
    主流Web开发模式有两种
    · 基于服务端渲染的传统Web开发模式
        服务器发送给客户端的HTML页面,是在服务器通过字符串的拼接,动态生成的.
        优点
            前端耗时少
            有利于SEO
        缺点
            占用服务器端资源
            不利于前后端分离,且开发效率低

    · 基于前后端分离的新型Web开发模式
        后端只负责提供API接口,前端使用Ajax调用接口
        优点
            开发体验好
            用户体验好
            减轻了服务端的渲染压力
        缺点
            不利于SEO
身份认证
    通过一定的手段,完成对用户身份的确认
    I)服务端渲染推荐使用session认证机制
        session认证机制
            HTTP协议具有无状态性,即服务器不会主动保留每次HTTP请求的状态
            解决方案:Cookie
                cookie是存储在用户浏览器中的一段不超过4kb的字符串.
                特性
                    · 自动发送
                    · 域名独立
                    · 过期时限
                    · 4kb限制
            客户端第一次请求服务器,服务器通过响应头的方式向客户端发送一个身份认证的cookie,
            客户端会自动将其存储在浏览器中;当客户端浏览器每次请求服务器的时候,浏览器会自动将身份认证相关的cookie
            通过请求头的方式发送给服务器,服务器即可验明客户端的身份.
            · 由于cookie存储在浏览器中且浏览器也提供了读写cookie的api,因此cookie不具有安全性.
            为了提高身份认证的安全性,增加了服务器端保存的用户信息,即session
                在服务器中缓存用户的登录信息,请求时进行核对.
        在Express中使用session认证
        · 安装express-session中间件
        · 配置
            const session = require('express-session')
            app.use(session({
                secret:'cabbage',
                resave:false,
                saveUninitialized:true
            }))
        //向session存数据
            //express-session配置完成后,即可通过req.session来访问和使用session对象,存储用户的关键信息
                app.post('/api/login',(req,res) => {
                    if(req.body.username !== 'admin' || req.body.password !== '123456') return res.send({status:1,msg:'登录失败!'})

            //将登陆成功后的用户信息,保存到session中
            //只有成功配置了express-session这个中间件之后,才有req.session这个属性
                req.session.user = req.body         //用户的信息
                req.session.islogin = true          //用户的登录状态
                res.send({status:0,msg:'登录成功!'})
            })
        //向session中取数据
            app.get('/api/username',(req,res) => {
                if(!req.session.islogin) return res.send({status:1,msg:'fail'})
                res.send({status:0,msg:'success',username:req.session.user.username})
            }
        //清空session
            //调用req.session.destroy()方法,即可清空服务器保存的session信息
            //退出登录的接口
            app.post('/api/logout',(req,res) => {
                //清空session信息
                req.session.destroy()
                res.send({status:0,msg:'退出登录成功!'})
            })

    II)前后端分离推荐使用JWT认证机制
        JWT是目前最流行的跨域认证解决方案
        用户的信息通过token字符串的形式,保存在客户端浏览器中,服务器通过还原token字符串的形式来认证用户身份
        组成
            Header(头部).Payload(有效载荷).Signature(签名)
        使用方式:
            客户端收到服务器返回的JWT之后,通常将它存储在localStorage或sessionStorage中
            此后,客户端每次与服务器通信,都要带上这个JWT.推荐做法是把它放在HTTP请求头的Authorization中
                Authorization: Bearer <token>
        在Express中使用JWT
        · 安装jsonwebtoken express-jwt
        · 导入
        · 定义secret密钥
            为保证JWT字符串安全性,需要定义一个用于加密和解密的secret密钥
            1.当生成JWT字符串的时候,需要使用secret密钥对用户的信息进行加密,最终得到加密好的JWT字符串
            2.当把JWT字符串解析还原成JSON对象的时候,需要使用secret密钥进行解密
                const secretKey = 'cabbage'
        · 登陆成功后生成JWT字符串
            //调用jsonwebtoken包提供的sign()方法,将用户信息加密成JWT字符串,响应给客户端
            //登录端口
                app.post('/api/login',(req,res) => {
                    //将req.body请求体中的数据,转存为userinfo常量
                    const userinfo = req.body
                    //登录失败
                    if (userinfo.username !== 'admin' || userinfo.password !== '123456') return res.send({status:400,message:'登录失败!'})
                    //登录成功
                    //调用jwt.sign()方法生成JWT字符串,并通过token属性发送给客户端
                    //参数1 用户的信息对象,参数2 加密的密钥,参数3 配置对象,可以配置当前token的有效期
                    //不要把密码加密到token字符中
                    const tokenStr = jwt.sign({username:userinfo.username},secretKey,{expiresIn:'300s'})
                    res.send({
                        status:200,
                        message:'登陆成功!',
                        token:tokenStr      //要发送给客户端的token字符串
                    })
                }
        · 注册将JWT字符串还原为JSON对象的中间件
            //express-jwt中间件配置好后,把解析出来的用户信息,挂载到req.user属性上
            //unless()方法相当于白名单.正则选择内的不需要通过token验证身份
                app.use(expressJWT({secret: secretKey}).unless({path:[/^\/api\//]}))
        · 使用req.user获取用户信息
            //express-jwt中间件配置成功后,在那些有权限的接口中,使用req.user对象,来访问从JWT字符串中解析出来的用户信息.
            //以下为一个有权限的API接口(需要token验证身份)
                app.get('/admin/getinfo',(req,res) => {
                    //使用req.user获取用户信息,并使用data属性将用户信息发送给客户端
                    console.log(req.user)
                    res.send({
                    status:200,
                    message:'获取用户信息成功!',
                    data:req.user               //要发送给客户端的用户信息
                    })
                })
        · 捕获解析JWT失败后产生的错误
            //捕获解析失败后产生的错误,防止其影响项目正常运行
            //注册全局错误处理中间件(注册在所有事件之后)
            app.use((err,req,res,next) => {
                //↓这次错误是由token解析失败导致的
                if (err.name === 'UnauthorizedError') return res.send({status:401,message:'无效的token'})
                res.send({status:500,message:'未知错误!'})
            })
