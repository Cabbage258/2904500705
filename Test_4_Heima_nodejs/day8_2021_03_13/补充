1.数组的解构赋值
    基本用法
        ES6允许按照一定模式,从数组和对象中提取质,对变量进行赋值,这被称为解构
        之前:    let a = 1,b = 2,c = 3
        ES6:    let[a,b,c] = [1,2,3]
        可以从数组中提取值,按照对应位置,对变量赋值
    本质上这种写法属于"模式匹配",只要等号两边的模式相同,左边的变量就会被赋予对应的值.
    例
        let [foo,[[bar],baz]] = [1,[[2],3]]
        foo //1
        bar //2
        baz //3

        let[ , ,third] = ["foo","bar","baz"]
        third //"baz"

        let [x, ,y] = [1,2,3]
        x //1
        y //3

        let [head, ..tail] = [1,2,3,4]
        head //1
        tail //[2,3,4]

        let [x,y, ...z] = ['a']
        x //"a"
        y //undefined
        z //[]
    如果解构不成功,变量的值就等于undefined
        let [foo] = []
        let [bar,foo] = [i]
    以上两种情况都属于解构不成功.foo的值都会等于undefined

    另一种情况是不完全解构,即等号左边的模式,只匹配一部分的等号右边的数组,这种情况下,解构依然可以成功
        let [x,y] = [1,2,3]
        x //1
        y //2

        let [a,[b],d] = [1,[2,3],4]
        a //1
        b //2
        d //4
    上面两个离子都属于不完全解构,但是可以成功

    如果等号的右边不是数组(严格地说,不是可遍历的结构),矮么将会报错
        let [foo] = 1
        let [foo] = false
        let [foo] = NaN
        let [foo] = undefined
        let [foo] = null
        let [foo] = {}
        //全部报错
    因为等号右边的值,要么转为对象以后不具备Iterator接口(前五个表达式),要么本身就不具备Iterator接口(最后一个表达式)

    对于Set结构,也可以使用数组的解构赋值
        let [x,y,z] = new Set(['a','b','c'])
    实际上,只要某种数据结构具有Iterator接口,都可以采用数组形式的解构赋值

