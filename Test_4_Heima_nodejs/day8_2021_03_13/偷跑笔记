1.初始化
    1.1创建项目
        1.新建api_server文件夹作为项目根目录,并在项目根目录中运行如下命令,初始化包管理配置文件
            npm init -y
        2.运行如下命令,安装特定版本的express
            npm i express@4.17.1
        3.在项目根目录中新建app.js作为整个项目的入口文件,并初始化如下的代码:
            //导入express模块
                const express = require('express')
            //创建express的服务器实例
                const app = express()
            //写代码留空

            //调用app.listen方法,指定端口号开启web服务器
                app.listen(3007,() => {
                    console.log('api server running at http://127.0.0.1:3007')
                })
    1.2配置cors跨域
        1.运行如下命令,安装cors中间件
            npm i cors@2.8.5
        2.在app.js中导入并配置cors中间件
            //导入cors中间件
                const cors = require('cors')
            //将cors注册为全局中间件
                app.use(cors())
    1.3配置解析表单数据的中间件
        1.铜鼓欧下的代码,配置解析 application/x-www-form-urlencoded 格式的表单数据的中间件
            app.use(express.urlencoded({extended:false}))
    1.4初始化路由相关的文件夹
        1.在项目根目录中,新建router文件夹,用来存放所有的路由模块
            路由模块汇总,只存放客户端的请求与处理函数之间的映射关系
        2.在项目根目录中,新建rtouter_handler文件夹,用来存放所有的路由处理函数模块
            路由处理函数模块中,专门负责存放每个路由对应的处理函数
    1.5初始化用户路由模块
        1.在router文件夹中,新建user.js文件,作为用户的路由模块,并初始化代码如下
            const express = require('express')
        //创建路由对象
            const router = express.Router()
        //注册新用户
            router.post('/reguser'.(req,res) => {res.send('reguser OK')})
        //登录
            router.post('/login',(req,res) => {res.send('login OK')})
        //将路由对象共享出去
            module.exports = router
        2.在app.js中,导入并使用用户路由模块
            //导入并注册用户路由模块
                const userRouter = require('./router/user')
                app.use('/api',userRouter)
    1.6抽离用户路由模块中的处理函数
        目的:为了保证路由模块的纯粹性,所有的路由处理函数,必须抽离到对应的路由处理函数模块中
        1.在/router_handler/user.js中,使用exports对象,分别向外共享如下两个路由处理函数:
        /*
            在这里定义和用户相关的路由处理函数,供 /router/user.js模块进行调用
        */
        //注册用户的处理函数
            exports.regUser = (req,res) => {res,send('reguser OK')}
        //登录的处理函数
            exports.login = (req,res) => {res.send('login OK')}
        2.将/router/user.js中的代码修改为如下结构
            const express = require('express')
            const router = express.Router()
        //导入用户路由处理函数模块
            const userHandler = require('../router_handler/user')
        //注册新用户
            router.post('/reguser',userHandler.rugUser)
        //登录
            router.post('/login',userHandler.login)

            module.exports = router
2.登录注册
    2.1新建ev_users表
        在my_db_01数据库中,新建ev_users表
    2.2安装并配置mysql模块
        在API接口项目中,需要安装并配置mysql这个第三方模块,来连接和操作MySQL数据库
        1.运行如下命令,安装mysql模块
            npm i mysql@2.18.1
        2.在项目根目录中新建/db/index.js文件,在此自定义模块中创建数据库的连接对象
        //导入mysql模块
            const mysql = require('mysql')
        //创建数据库连接对象
            const db = mysql.createPool({
                host:'127.0.0.1',
                user:'root',
                password:'root',
                database:'my_db_01'
            })
        //向外共享db数据库连接对象
            module.exports = db
    2.3注册
    实现步骤
        I)检测表单数据是否合法
            1.判断用户名和密码是否为空
            //接收表单数据
                const userinfo = req.body
            //判断数据是否合法
                if(!userinfo.username || !userinfo.password) return res.send({status:1,message:'用户名或密码不能为空!'})

        II)检测用户名是否被占用
            1.导入数据库操作模块
                const db = require('../db/index')
            2.定义SQL语句
                const sql = 'select * from ev_users where username=?'
            3.执行SQL语句并根据结果判断用户名是否被占用
                db.query(sql,[userinfo.username],(err,results) => {
            //执行SQL语句失败
                if (err) return res.send({status:1,message:err.message})
            //用户名被占用
                if (results.length > 0) return res.send({status:1,message:'用户名被占用,请跟换其他用户名!'})
            //用户名可用,继续后续流程...
            }

        III)对密码进行加密处理
            为了保证密码的安全性,不建议在数据库以明文的形式保存用户密码,推荐对密码进行加密存储
            在当前项目中,使用bcryptjs对用户密码进行加密,优点:
                · 加密之后的密码,无法被逆向破解
                · 同一明文密码多次加密,得到的加密结果各不相同,保证了安全型
            1.运行如下命令,安装指定版本的bcrptjs
                npm i bcryptjs@2.4.3
            2.在/router_handler/user/js中,导入bcryptjs
                const bcrypt = require('bcryptjs')
            3.在注册用户的处理函数中,确认用户名可用之后,调用bcrypt.hashSync(明文密码,随机盐的长度)方法,对用户的密码进行加密处理
            //对用户的密码,进行bcrypt加密,返回值是加密之后的密码字符串
                userinfo.password = bcrypt.hashSync(userinfo.password,10)

        IV)插入新用户
            1.定义插入用户的SQL语句
                const sql = 'insert into ev_users set ?'
            2.调用db.query()执行SQL语句,插入新用户
                db.query(sql,{username:userinfo.username,password:userinfo.password},(err,results) => {
            //执行SQL语句失败
                if (err) return res.send({status:1,message:err.message})
            //执行成功,但影响行数不为1
                if (results.affectedRows !== 1) return res.send({status:1,message:err.message})
            //注册成功
                res.send({status:0,message:'注册成功!'})
    2.4优化res.send()代码
        在处理函数中,需要多次调用res.send()向客户端响应处理失败的结果,为了简化代码,可以手动封装一个res.cc()函数
            1.在app.js中,所有路由之前,声明一个全局中间件,为res对象挂在一个res.cc()函数:
            //响应数据的中间件
                app.use((req,res,next) => {
            //status = 0为成功;status = 1为失败;默认将status的值设置为1,方便处理失败的情况
                res.cc = (err,status = 1) => {
                    res.send({
                        status,message:err instanceof Error ? err.message : err
                        })
                    }
                    next()
                }
    2.5优化表单数据验证
        表单验证的原则:前端验证为辅,后端验证为主,后端永远不要相信前端提交过来的任何内容
        在实际开发中,前后端都需要对表单的数据进行合法性的验证.而且,后端作为数据合法性验证的
        最后一个关口,在拦截非法数据方面,起到了至关重要的作用.
        单纯的使用if...else...的形式对数据和发行进行验证,效率低下、出错率高、维护性差.
        因此,推荐使用第三方数据验证模块,来降低出错率、提高验证的效率与可维护性,让后端
        程序员把更多的精力放在核心业务逻辑的处理上
            1.安装@hapi/joi包,为表单中携带的每个数据项,定义验证规则
                npm i @hapi/joi@17.1.0
            2.安装@escook/express-joi中间件,来实现自动对表单数据进行验证的功能
                npm i @escook/express-joi
            3.新建/schema/user.js用户信息验证规则模块,并初始化代码如下
                const joi = require('@hapi/joi')
            /*
                string()值必须是字符串
                alphanum()值只能是包含a-zA-Z0-9的字符串
                min(length)最小长度
                max(length)最大长度
                required()值是必填项,不能为undefined
                pattern(正则表达式)值必须符合正则表达式的规则
            */
            //用户名的验证规则
                const username = joi.string().alphanum().min(1).max(10).required()
            //密码的验证规则
                const password = joi
                    .string()
                    .pattern(/^[/s]{6,12}$/)
                    .required()
            //注册和登录表单的验证规则对象
                exports.reg_login_schema = {
            //表示需要对req.body中的数据进行验证
                body:{
                    username,
                    password
                    }
                }
            4.修改/router/user.js中的代码如下
                const express = require('express')
                const router = express.Router()
            //导入用户路由处理函数模块
                const userHandler = require('../router_handler/user')
            //1.导入验证表单数据的中间件
                const expressJoi = require('@escook/express-joi')
            //2.导入需要的验证规则对象
                const {reg_login_schema} = require('../schema/user')
            //注册新用户
            //3.在注册新用户的路由中,声明局部中间件,对当前请求中携带的数据进行验证
            //3.1数据验证通过后,会把这次请求流转给后面的路由处理函数
            //3.2数据验证失败后,终止后续代码的执行,并抛出一个全局的Error错误,进入全局错误级别中间件中进行处理
                router.post('/reguser',expressJoi(reg_login_schema),userHandler.regUser)
            //登录
                router.post('/login',userHandler.login)
            //暴露给外部
                module.exports = router
            5.在app.js的全局错误级别中间件中,捕获验证失败的错误,并把验证失败的结果响应给客户端
                const joi = require('@hapi/joi')
            //错误中间件
                app.use((err,req,res,next) => {
            //数据验证失败
                if (err instanceof joi.ValidationError) return res.cc(err)
                res.cc(err)
                }
    2.6登录
        实现步骤
        I)检测表单数据是否合法
            1.将/router/user.js中登录的路由代码修改如下:
            //登录的路由
                router.post('/login',expressJoi(reg_login_schema),userHandler.login)



        II)根据用户名查询用户的数据
            //接收表单数据
                const userinfo = req.body
            2.定义SQL语句
                const sql = 'select * from ev_users where username=?'
            3.执行SQL语句,查询用户的数据
                db.query(sql,userinfo.username,(err,results) => {
            //执行SQL语句失败
                if (err) return res.cc(err)
            //执行SQL语句成功,但是查询到数据条数不等于1
                if (results.length !== 1) return res.cc('登录失败!')
            //判断用户输入的登录密码是否和数据库中的密码一致
                })


        III)判断用户输入的密码是否正确
            核心实现思路:调用bcrypt.compareSync(用户提交的密码,数据库中的密码)方法比较密码是否一致
            返回值是布尔值(true一致、false不一致)
            具体的实现代码如下:
            //拿着用户输入的密码,和数据库中存储的密码进行对比
                const compareResult = bcrypt.compareSync(userinfo.password,results[0].password)
            //如果对比的结果等于false,则证明用户输入的密码错误
                if (!compareResult) return res.cc('登录失败!')
        IV)生成JWT的token字符串
            核心注意点:在生成token字符串的时候,一定要剔除密码和头像的值
            1.通过ES6的高级语法,快速剔除密码和头像的值
            //剔除完毕之后,user中只保留了用户的id,username,nickname,email这四个数形的值
                const user = {...results[0],password:'',user_pic:''}
            2.运行如下的命令,安装生成token字符串的包
                npm i jsonwebtoken@8.5.1
            3.在/router_handler/user.js模块的头部区域,导入jsonwebtoken包
            //用这个包来生成token字符串
                const jwt = require('jsonwebtoken')
            4.创建config.js文件,并向外共享加密和还原token的jwtSecretKey字符串
                module.exports = {
                    jwtSecretKey:'cabbage'
                }
            5.将用户信息对象加密成token字符串
            //导入配置文件
                const config = require('../config')
            //生成token字符串
                const tokenStr = jwt.sign(user,config.jwtSecretKey,{
                    expiresIn:'10h',        //token有效期为10个小时
                })
            6.将生成的token字符串响应给客户端
                res.send({
                    status:0,
                    message:'登陆成功!',
            //为了方便客户端使用token,在服务器端直接拼上Bearer的前缀
                    token:'Bearer' + tokenStr
                })
    2.7配置解析token的中间件
        1.运行如下的命令,安装解析token的中间件
            npm i express-jwt@5.3.3
        2.在app.js中注册路由之前,配置解析token的中间件
        //导入配置文件
            const config = require('./config')
        //解析token的中间件
            const expressJWT = require('express-jwt')
        //使用.unless({path:[/^\/api\//]})指定哪些接口不需要进行token的身份认证
            app.use(expressJWT({secret:config.jwtSecretKey}).unless({path:[/^\/api\//]}))
        3.在app.js中的错误级别中间件里面,捕获并处理token认证失败后的错误
        //错误中间件
            app.use((err,req,res,next) => {
        //省略其他代码
            ...
        //捕获身份认证失败的错误
            if (err.name === 'UnauthorizedError') return res.cc('身份认证失败!')
        //未知错误...
            ...
        })
3.个人中心

