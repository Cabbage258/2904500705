原型对象概述
    1.构造函数缺点
        JavaScript通过构造函数为实例对象定义属性,虽然很方便,但是有一个缺点
        同一个构造函数的多个实例之间,无法共享属性,从而造成对系统资源的浪费.
        这个问题的解决方法,就是JavaScript的原型对象(prototype)
    2.prototype属性的作用
        JavaScript继承机制的设计思想就是,原型对象的所有属性和方法,都能被实例对象共享.也就是说,
        如果属性和方法按定义在原型上,那么所有实例对象就能共享.
        JavaScript规定,每个函数都有一个prototype属性,指向一个对象.
        对于普通函数来说,该属性基本无用,但是对于构造函数来说,生成实例的时候,该属性会自动成为实例对象的原型.
        原型对象的属性不是实例对象自身的属性.
        只要修改原型对象,变动就会立刻体现在所有实例对象上.

        当实例对象本身没有某个属性或方法的时候,它会到原型对象去寻找该属性或方法,
        如果实例对象自身就有某个属性或方法,它就不会再去原型对象寻找这个属性或方法.
        对象都会有一个属性__proto__(即对象原型),指向构造函数的prototype原型对象,之所以能寻找使用原型对象,
        就是因为有_proto_指向构造函数的原型对象.且
            构造函数的原型对象 === 对象实例的对象原型 //true
        注意:
            __proto__是一个非标准属性,所以不能使用该属性,它只是内部指向原型对象prototype.

        构造函数可以通过 构造函数.prototype 指向 构造函数的原型对象prototype
        构造函数的原型对象prototype可以通过 构造函数.prototype.constructor 指向 构造函数
        构造函数 new 实例对象
        实例对象可以通过 实例对象.__proto__ 指向构造函数的原型对象prototype


        总结:
            原型对象的作用,就是定义所有实例对象共享的属性和方法,这也是它被称为原型对象的原因,而实例对象可以视作从原型对象衍生出来的子对象.

        Tips:
            ES6中类的本质是构造函数的语法糖
            在类中的constructor构造器内添加的属性方法会添加到类的实例化对象本身上
            类中直接写的属性方法会添加到类的原型对象中
            实例化之后调用属性方法优先寻找constructor中的,即优先寻找实例化对象本身的属性方法
            如果没有,再向上寻找,即寻找在类的原型对象中的属性方法
    3.原型链
        JavaScript规定,所有对象都有自己的原型对象(prototype)
        一方面,任何一个对象都可以充当其他对象的原型;
        另一方面,由于原型对象也是对象,所以它也有自己的原型.
        因此就会形成一个原型链(prototype chain):对象到原型,再到原型的原型...
        如果一层层上溯,所有对象的原型最终都可以上溯到Object.prototype
        即Object构造函数的prototype属性.
        也就是说,所有对象都继承了Object.prototype的属性
        这就是所有对象都有valueOf和toString方法的原因,因为这是从Object.prototype继承的.

        Object.getPrototypeOf(obj)  //返回给定对象的原型,如果没有继承的属性,则返回null
        console.log(Object.getPrototypeOf(Object.prototype))    //null
        Object.prototype对象的原型是null,也就是说,原型链的尽头是null

继承
    ES6之前并没有给我们提供extends继承.可以通过构造函数+原型对象 模拟实现继承,被称为组合继承.
    i)call()
        fun.call(thisArg,arg1,arg2,...)
            this.Arg:当前调用函数this的指向对象
            arg1,arg2:传递的其他参数
    ii)借用构造函数继承父类型属性
        核心原理:通过call()把父类型的this指向子类型的this
    iii)借用原型对象继承父类型方法
        一般情况下,对象的方法都在构造函数的原型对象中设置,通过构造函数无法继承父类方法.
        核心原理:
            · 将子类所共享的方法提取出来,让子类的prototype原型对象 = new 父类()
            · 本质:子类原型对象等于是实例化父类,因为父类实例化之后另外开辟空间,就不会影响原来父类原型对象
            · 将子类的constructor重新指向子类的构造函数
ES5中的新增方法
    a)数组方法
        迭代(遍历)方法:forEach()、map()、filter()、some()、every()
        i)
            array.forEach(function(数组当前项的值,数组当前项的索引,数组对象本身))      //参数可以省略
        ii)
            array.filter(function(数组当前项的值,数组当前项的索引,数组对象本身))       //参数可以省略
            filter()方法创建一个新的数组,新数组中的元素是通过检查指定数组中符合条件的所有元素,主要用于筛选数组.
                返回的是一个新数组,包含符合条件的元素
        iii)
            array.some(function(数组当前项的值,数组当前项的索引,数组对象本身))         //参数可以省略
            some()方法用于查找数组中是否有满足条件的元素.
                返回的是布尔值,true/false.如果有一个满足条件的元素,将直接终止循环,不再继续查找.
    b)字符串方法
        str.trim()
            trim()方法会从一个字符串的两端删除空白字符(空格).
                返回一个新的字符串,不会影响原字符串本身
    c)对象方法
        i)Object.keys(obj)
            Object.keys()方法返回一个由一个给定对象的自身可枚举属性组成的字符串数组,顺序为遍历顺序
            效果类似for...in
            输出对象中值大于2的key的数组
            Tips:
                Object()对象中的属性不可枚举,所以返回为[]

        ii)Object.defineProperty(目标对象,需定义或修改的属性的名字,目标属性所拥有的特性)          //参数不能省略
            Object.defineProperty()定义新属性或修改原有的属性
            应当直接在Object构造器对象上调用此方法,而不是在任意实例上调用
            目标属性所拥有的特性:{
                · value:设置属性的值(可以为数值,对象,函数等)
                · writable:值是否可以重写     true|false(默认值)
                · enumerable:目标属性是否可以被枚举    true|false(默认值)
                · configurable:目标属性书否可以被删除或是否可以再次修改特性   true|false(默认值)
                }
                使用时就算未设置特性也会对通过该方法操作的属性加上默认值:
                    不可通过赋值运算符的方式改变,不可被枚举,不可被删除或再次修改特性特性特性