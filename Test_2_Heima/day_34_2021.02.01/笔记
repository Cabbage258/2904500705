1.改变this指向
    i)Function.prototype.call()
        函数实例的call方法,可以指定函数内部this的指向(即函数执行时所在的作用域),然后在指定的作用域中,调用该函数.
        func.call(指向对象,参数1,参数2,...)
        后面参数是函数调用时所需的参数
        如果call方法的参数是一个原始值,那么这个原始值会自动转成对应的包装对象,然后传入call方法.


    ii)Function.prototype.apply()
        与call方法累类似,区别是接受一个[数组]作为函数执行时的参数.
        func.apply(指向对象,[该数组所有成员依次作为参数传入原函数(必须以数组形式添加)])
        Tips:
            a)找出数组中的最大元素
                结合使用apply方法和Math.max方法,可以返回数组中的最大值(可以将数组传参到求最大值方法中)
            b)将数组的空元素变为undefined
                将数组空元素变为undefined.数组的forEach方法会跳过空元素,但不会跳过undefined
            c)转换类似数组的对象
                利用数组对象的slice方法,可以将一个类似数组的对象(例如arguments)转为真正的数组
                前提是被处理的对象必须有length属性以及相对应的数字键
                    即属性作为索引号,length在对象中作为一个属性写入
                    {索引号:number,索引号:number,length:this.length}
            d)绑定回调函数的对象

    iii)Function.prototype.bind()
        用于将函数体内的this绑定到某个对象,然后返回一个新函数(不调用函数,使用频率高)
        function.bind(指向对象,参数1,参数2,...)
        对包装函数做任何调用都会优先用参数1,参数2,...依次传参,只需再传入未传的形参即可

2.严格模式(strict)
https://developer.mozilla.org/zh-CN/search?q=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F
    1.设计目的
        ...
    2.启用方法
        'use strict'
        老版本的引擎会把它当做一行普通字符串忽略,新版本的引擎会进入严格模式
        严格模式可以作用于整个脚本,也可以只作用于单个函数.
        i)整个脚本文件
            'use strict'放在脚本文件第一行,整个脚本都将以严格模式运行.
            必须写在产生实际运行结果语句之前,否则无作用
        ii)单个函数
            'use strict'放在函数体的第一行,则整个函数将以严格模式运行.
        Tips:
            有时需要把不同的脚本合并在一个文件里面.如果一个为严格模式,另一个脚本不是,谁在前,
            合并后的脚本就以谁的模式为准,但这两种情况下合并后的结果都是不正确的.
            此时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中.

    3.显式报错
        严格模式使得js语法变的更严格,更多正常模式下静默失效的语法会被显式报错.
        i)只读属性不可写
        ii)只设置了取值器的属性不可写
        iii)禁止扩展的对象不可扩展
        iv)eval、arguments不可用作标识名
        v)函数不能有重名的参数
        vi)禁止八进制的前缀()表示法
    4.增强的安全措施
        i)全局变量显式声明
        ii)禁止this关键字指向全局对象
        iii)禁止使用fn.calle、fn.caller
        iv)禁止使用arguments.calle、arguments.caller
        v)禁止删除变量
    5.静态绑定
        i)禁止使用with语句
        ii)创设eval作用域
        iii)arguments不再追踪参数的变化
    6.向下一个版本的JavaScript过渡
        i)非函数代码块不得声明函数
        ii)保留字
3.高阶函数
    高阶函数是对其它函数进行操作的函数,它接收函数作为参数或将函数作为返回值输出.
4.闭包(closure)
    闭包是JavaScript语言的特色,很多高级应用都需要靠闭包来实现.
    闭包让你可以在一个内层函数中访问到其外层函数的作用域.
    在JavaScript中,每当创建一个函数,闭包就会在函数创建的同时被创建出来.
    闭包简单来说就是'定义在一个函数内部的函数'
    优点:
        · 减少全局变量的使用,保证了内部变量的安全,同时外部函数也可以访问内部函数的变量.
        · 在内存中维持一个变量,也可以用作缓存.
    缺点:
        · 被引用的内部变量不能被销毁,增大了内存消耗,使用不当易造成内存泄漏,解决办法可以在内部变量不使用时,把外部的引用置为null
        · 闭包就是函数建的跨作用域访问,会导致性能损失.
    Tips:
        立即执行函数和闭包的区别
            立即执行函数和闭包没有关系,虽然两者会经常结合子啊一起使用,但两者有本质的不同
            立即执行函数只是函数的一种调用方式,只是生命完之后立即执行,这类函数一般都是只调用一次(可用于单例对象上),
            调用完之后会立即销毁,不会占用内存.
            闭包则是主要让外部函数可以访问内部函数的作用域,也减少了全局变量的使用,保证了内部变量的安全,
            但因被引用的内部变量不能被销毁,增大了内存消耗,使用不当易造成内存泄漏.
5.垃圾回收机制
    JavaScript中内存管理的主要概念是可达性.
    简单地说,"可达性"值就是那些以某种方式可访问或可用的值,它们被保证存储在内存中.
        1.有一组基本的固有可达值,由于显而易见的原因无法删除
            · 本地函数的局部变量和参数
            · 当前嵌套调用链上的其他函数的变量和参数
            · 全局变量
            · 还有一些其他的,内部的
        这些值成为根
        2.如果引用或因用力按可以从根访问任何其他值,则认为该值是可访问的.
            例如,如果局部变量中有对象,并且该对象具有引用另一个对象的属性,则该对象被视为可达性,它所引用的那些属性也是可以访问的.
    内部算法:
        基本的垃圾回收算法成为"标记-清除",定期执行以下"垃圾回收"步骤
            · 垃圾回收器获取根并"标记"(记住)它们
            · 然后它访问并"标记"所有来自它们的引用
            · 然后它访问标记的对象并标记它们的引用.所有被访问的对象都被记住,以便以后不再访问同一个对象两次
            · 以此类推,直到有未访问的引用(可以从根访问)为止
            · 除标记的对象外,所有对象都被删除.





