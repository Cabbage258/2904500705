<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>let命令</title>
</head>
<body>

</body>
</html>
<script>
    /*
    {
        let a = 10
        var b = 1
    }
    console.log(a)  //报错
    console.log(b)  //1
    */
    //上面代码在代码块之中,分别用let和var声明了两个变量.然后在代码块之外调用这两个变量,结果let声明的变量报错.
    //var声明的变量返回了正确的值.
    //这表明let声明的变量只在它所在的代码块有效.
    /*
    //例:
    //  下面的代码如果使用var,最后输出的是10
        var a = []
    for (var i = 0;i < 10;i++){ //变量i是var命令声明的,所以在全局范围内都有效,所以全局只有一个变量i
        a[i] = function(){      //每一次循环,变量i的值都会发生改变
            console.log(i)      //而循环内被赋给数组a的函数内部的console.log(i),里面的i指向就是全局的i.
        }                       //也就是说,所有数组a的成员里面的i,指向的都是同一个i,导致运行时输出的是最后一轮的i的值,也就是10
    }
    a[6]()  //10
    */
    /*
    //如果使用let,声明的变量仅在块级作用域内有效,最后输出的是6
    var a = [];
    for (let i = 0; i < 10; i++) {  //变量i是let声明的
        a[i] = function () {        //当前的i只在本轮循环有效,所以每一次循环的i其实都是一个新的变量
            console.log(i);
        };
    }
    a[6](); // 6                      所以最后输出的是6
    //如果每一轮循环的i都是重新声明的,那它怎么知道上一轮循环的值,从而计算出本轮循环的值?
    //因为JavaScript引擎内部会记住上一轮循环的值,初始化本轮的变量i时,就在上一轮循环的基础上进行计算.
    //Tips:
    //  for循环还有一个特别指出,就是设置循环变量的那部分是一个父作用域,而循环体内部是一个单独的子作用域
    for(let i = 0; i < 3;i++){
        let i = 'abc'
        console.log(i)
    }
    //abc
    //abc
    //abc
    //所以函数内部的变量i与循环变量i不在同一个作用域,有各自单独的作用域.
    */
    /*
    function bar(x = y,y = 2){
        return[x,y]
    }
    bar()   //报错:在初始化y之前不能访问y
    */
     function bar1(x = 2,y = x){
        return[x,y]
    }

    console.log(bar1())   //[2,2]


</script>